import sys
from typing import TextIO, Dict
from assembler.expression import Context, ExpressionException, Constant
from assembler.asm.instruction import Instruction
from assembler.asm.instruction_interface import InstructionInterface
from assembler.asm.instruction_visitor import InstructionVisitor
from assembler.asm.machine_code_listener import MachineCodeListener

class AsmFormatter(InstructionVisitor):
    """Formats a Program into a human-readable assembly listing."""

    def __init__(self, out: TextIO = sys.stdout, include_line_numbers: bool = True, indent_created: bool = True):
        self._out = out
        self._include_line_numbers = include_line_numbers
        self._indent_created = indent_created
        self._column_offset = 0 if include_line_numbers else 6
        self._act_col = 0
        self._addr_to_line_map: Dict[int, int] = {} # Store mapping created during formatting

    @property
    def addr_to_line_map(self) -> Dict[int, int]:
        return self._addr_to_line_map

    def _print(self, s: str):
        print(s, end="", file=self._out)
        self._act_col += len(s)

    def _new_line(self):
        print(file=self._out)
        self._act_col = 0

    def _tab(self, col: int):
        target_col = col - self._column_offset
        while self._act_col < target_col:
            self._print(" ")

    def _print_hex(self, value: int, width: int = 4):
        hex_str = f"{value & 0xFFFF:x}" # Mask to 16 bits for display
        padded_hex = hex_str.zfill(width)
        self._print(padded_hex)

    def _is_created(self, i: InstructionInterface) -> bool:
        """Check if instruction was likely generated by a macro or directive."""
        return i.line_number == 0 or i.macro_description is not None

    def visit(self, i: InstructionInterface, context: Context) -> bool:
        # --- Print Pending Comment ---
        if i.comment:
            # Simple print for now, could format better
             print(f"; {i.comment}", file=self._out) # Print comment above


        # --- Print Label (if long) and Macro Description ---
        label_is_printed = False
        if i.label and len(i.label) > 8:
             self._tab(22)
             self._print(f"{i.label}:")
             self._new_line()
             label_is_printed = True

        if i.macro_description:
            self._tab(32)
            self._print(f"; Macro: {i.macro_description}") # Mark as macro
            self._new_line()

        # --- Line Number ---
        if self._include_line_numbers:
            line_str = str(i.line_number) if i.line_number > 0 else " "
            self._print(f"{line_str:>3} | ") # Right-align line number
        else:
             self._print("    | ") # Placeholder if no lines

        # --- Address and Machine Code ---
        addr = context.instr_addr
        self._addr_to_line_map[addr] = i.line_number # Store mapping
        self._print_hex(addr)
        self._print(": ")

        class CodeCollector(MachineCodeListener):
            def __init__(self, formatter: 'AsmFormatter'):
                self.codes = []
                self.formatter = formatter
            def add(self, instr: int):
                self.codes.append(instr)
                self.formatter._print_hex(instr)
                self.formatter._print(" ")

        code_collector = CodeCollector(self)
        try:
            i.create_machine_code(context, code_collector)
        except ExpressionException as e:
             self._print(f"<CodeGen Error: {e}>") # Show error in listing


        # --- Print Label (if short) ---
        if not label_is_printed and i.label:
            self._tab(22)
            self._print(f"{i.label}:")

        # --- Print Instruction Mnemonic and Operands ---
        indent = 2 if self._indent_created and self._is_created(i) else 0
        self._tab(32 + indent)

        if isinstance(i, Instruction):
            ins = i
            opcode = ins.opcode
            self._print(f"{opcode.name:<6}") # Pad opcode name

            self._tab(38 + indent)

            args_str = opcode.arguments.format(ins)
            self._print(args_str)

            # Add constant value comment if applicable
            if ins.constant is not None and opcode.arguments.has_const:
                try:
                     # Get value directly if possible
                     const_val = ins.constant.get_value(context)
                     self._tab(55)
                     self._print(f"; 0x{const_val & 0xFFFF:x}")
                except ExpressionException:
                     # Value depends on context not fully resolved yet?
                     self._tab(55)
                     self._print(f"; {ins.constant}") # Print expression string
        else:
             # For DataInstruction or others
             self._print(str(i)) # Use its __str__ method

        self._new_line()
        return True

